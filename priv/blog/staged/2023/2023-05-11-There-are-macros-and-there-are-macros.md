---
published_at: "2023-05-11 20:00:29.789858Z"
state: "published"
past_slugs: []
slug: "there-are-macros"
title: "There are macros and there are *macros*"
created_at: "2023-05-11 19:39:18.027487Z"
id: "176fb334-6f5c-4ed8-bb16-54b4359eafa0"
tag_line: "Not all macros are built the same."
tag_names:
  - "elixir"
  - "ash"
  - "macros"
author: "Zach Daniel"
body_html: '<p>__ash_blog_newline_hack__  A common criticism of Ash is that it has too many macros. This is an understandable position to take, but I think its important to distinguish between two main kinds of macros. One of them should be used extremely sparingly, and the other I think its okay to use a bit more liberally. We’ll call them “configuration macros” and “metaprogramming macros”. Keep in mind these names are a bit made up and the boundary between the two is not always cut and dry. When people talk about “magic” in the context of macros, they are mostly talking about “metaprogramming macros”. Lets take a look at some examples.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<h2 id="metaprogramming-macros" class="flex flex-row items-center">__ash_blog_newline_hack__  <a href="#metaprogramming-macros">__ash_blog_newline_hack__    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">__ash_blog_newline_hack__      <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1">__ash_blog_newline_hack__      </path>__ash_blog_newline_hack__    </svg>__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  <span>__ash_blog_newline_hack__    Metaprogramming Macros__ash_blog_newline_hack__  </span>__ash_blog_newline_hack__</h2>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  This snippet is from__ash_blog_newline_hack__  <a href="https://github.com/elixir-nx/nx/tree/main/nx#readme">__ash_blog_newline_hack__    NX__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  . This function can run as regular elixir code, or it can be compiled to run using multiple backends meant for numerical processing, including running on the GPU. The code that is actually compiled under the hood looks__ash_blog_newline_hack__  <em>__ash_blog_newline_hack__    dramatically__ash_blog_newline_hack__  </em>__ash_blog_newline_hack__  different from what you see in front of you. This is not a bad thing! If you had to use or write the actual underlying code, you’d get nothing done. Check out Nx’s documentation for more.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="kd">defn</span><span class="w"> </span><span class="nf">softmax</span><span class="p" data-group-id="9498308807-1">(</span><span class="n">t</span><span class="p" data-group-id="9498308807-1">)</span><span class="w"> </span><span class="k" data-group-id="9498308807-2">do</span><span class="w">__ash_blog_newline_hack__  </span><span class="nc">Nx</span><span class="o">.</span><span class="n">exp</span><span class="p" data-group-id="9498308807-3">(</span><span class="n">t</span><span class="p" data-group-id="9498308807-3">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nc">Nx</span><span class="o">.</span><span class="n">sum</span><span class="p" data-group-id="9498308807-4">(</span><span class="nc">Nx</span><span class="o">.</span><span class="n">exp</span><span class="p" data-group-id="9498308807-5">(</span><span class="n">t</span><span class="p" data-group-id="9498308807-5">)</span><span class="p" data-group-id="9498308807-4">)</span><span class="w">__ash_blog_newline_hack__</span><span class="k" data-group-id="9498308807-2">end</span></code></pre><p>__ash_blog_newline_hack__  Here is an example from__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Nebulex">Nebulex</code>  , an ETS based caching library. In this example, the metaprogramming is quite hidden from you. The actual logic happens in a__ash_blog_newline_hack__  <a href="https://hexdocs.pm/elixir/1.12/Module.html#module-compile-callbacks">__ash_blog_newline_hack__    <em>__ash_blog_newline_hack__      compiler callback__ash_blog_newline_hack__    </em>__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  . It involves rewriting the functions to intercept calls and decide if the cached version should be used, or if the value should be computed and cached. This kind of macro is quite magical given how indirect it is, but at the same time in applications where cached functions are common, it stops feeling like magic and starts feeling like a language feature. If I was looking at a large code-base that used this once, I’d likely be concerned. The mental overhead of understanding it for one single case likely isn’t worth it.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Example</span><span class="w"> </span><span class="k" data-group-id="1290425288-1">do</span><span class="w">__ash_blog_newline_hack__  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Nebulex.Caching</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__  </span><span class="na">@decorate</span><span class="w"> </span><span class="n">cacheable</span><span class="p" data-group-id="1290425288-2">(</span><span class="ss">cache</span><span class="p">:</span><span class="w"> </span><span class="nc">MyApp.Cache</span><span class="p">,</span><span class="w"> </span><span class="ss">key</span><span class="p">:</span><span class="w"> </span><span class="ss">:cache_key</span><span class="p" data-group-id="1290425288-2">)</span><span class="w">__ash_blog_newline_hack__  </span><span class="kd">def</span><span class="w"> </span><span class="nf">get_by_name</span><span class="p" data-group-id="1290425288-3">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="1290425288-3">)</span><span class="w"> </span><span class="k" data-group-id="1290425288-4">do</span><span class="w">__ash_blog_newline_hack__    </span><span class="n">...</span><span class="w">__ash_blog_newline_hack__  </span><span class="k" data-group-id="1290425288-4">end</span><span class="w">__ash_blog_newline_hack__</span><span class="k" data-group-id="1290425288-1">end</span></code></pre><p>__ash_blog_newline_hack__  This one is from__ash_blog_newline_hack__<a href="https://hexdocs.pm/ash"><code class="inline maybe-module text-black dark:text-white" data-module="Ash">Ash</code></a>. We do similar magic to the__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Nx">Nx</code>  example from above for this. Specifically, we have an expression that can be run natively to a data layer (i.e__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="SQL">SQL</code>  ) or in elixir. And Ash reserves the right to decide where it gets run, depending on the context and requirements.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="n">calculate</span><span class="w"> </span><span class="ss">:full_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="2275295221-1">(</span><span class="n">first_name</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">last_name</span><span class="p" data-group-id="2275295221-1">)</span></code></pre><p>__ash_blog_newline_hack__  As you can see, all of these examples represent a significant amount of complexity boiled down to very simple macros. This will also be true of the upcoming examples of “configuration macros”, but the big difference here is that each macro call represents very complex code being executed on your behalf.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<h2 id="configuration-macros" class="flex flex-row items-center">__ash_blog_newline_hack__  <a href="#configuration-macros">__ash_blog_newline_hack__    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">__ash_blog_newline_hack__      <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1">__ash_blog_newline_hack__      </path>__ash_blog_newline_hack__    </svg>__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  <span>__ash_blog_newline_hack__    Configuration Macros__ash_blog_newline_hack__  </span>__ash_blog_newline_hack__</h2>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  Lets take a look at some examples of macros that I would consider__ash_blog_newline_hack__  <em>__ash_blog_newline_hack__    less__ash_blog_newline_hack__  </em>__ash_blog_newline_hack__  magical.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  This one is likely familiar to most people who have worked with Elixir professionally. Here we have an Ecto.Schema. In this example we actually have three separate macros. The__ash_blog_newline_hack__<code  class="inline maybe-local-call text-black dark:text-white" data-fun="schema" data-arity="2">schema/2</code>  macro sets up some module attributes, and__ash_blog_newline_hack__<code  class="inline maybe-local-call text-black dark:text-white" data-fun="field" data-arity="2">field/2</code>  adds to those module attributes.__ash_blog_newline_hack__<code  class="inline maybe-local-call text-black dark:text-white" data-fun="timestamps" data-arity="0">timestamps/0</code>  sets up the schema to track__ash_blog_newline_hack__<code class="inline text-black dark:text-white">inserted_at</code>  and__ash_blog_newline_hack__<code class="inline text-black dark:text-white">updated_at</code>  timestamps. On its own, however, an__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Ecto.Schema">Ecto.Schema</code>  doesn’t really__ash_blog_newline_hack__  <em>__ash_blog_newline_hack__    do__ash_blog_newline_hack__  </em>__ash_blog_newline_hack__  anything. There also isn’t a bunch of code hidden behind the scenes that you need to be aware of being executed. This sets up some information on the module that can be read back later. For example:__ash_blog_newline_hack__<code class="inline text-black dark:text-white">MyApp.MySchema.__schema__(:fields)</code>  would return__ash_blog_newline_hack__<code class="inline text-black dark:text-white">[:field_name, :inserted_at, :updated_at]</code>  in this case. This is a classic example of what I’d call a “configuration macro”.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.MySchema</span><span class="w"> </span><span class="k" data-group-id="8883004481-1">do</span><span class="w">__ash_blog_newline_hack__  </span><span class="n">schema</span><span class="w"> </span><span class="s">&quot;table&quot;</span><span class="w"> </span><span class="k" data-group-id="8883004481-2">do</span><span class="w">__ash_blog_newline_hack__    </span><span class="n">field</span><span class="w"> </span><span class="ss">:field_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:type</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__    </span><span class="n">timestamps</span><span class="p" data-group-id="8883004481-3">(</span><span class="p" data-group-id="8883004481-3">)</span><span class="w">__ash_blog_newline_hack__  </span><span class="k" data-group-id="8883004481-2">end</span><span class="w">__ash_blog_newline_hack__</span><span class="k" data-group-id="8883004481-1">end</span></code></pre><p>__ash_blog_newline_hack__  Here we can see an example from__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Absinthe">Absinthe</code>  ‘s documentation. Absinthe is a tool for building GraphQL apis with Elixir. This one slightly straddles the line between “configuration macros” and “metaprogramming macros”, but I think still lands on the side of a “configuration macro”. We configure a field in our GraphQL API, and how to resolve it. There are quite a few macros involved in building an API with__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Absinthe">Absinthe</code>  . Here we configure what code gets run to resolve a given field, but ultimately the responsibility for what code runs is our own.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">BlogWeb.Schema</span><span class="w"> </span><span class="k" data-group-id="7493131802-1">do</span><span class="w">__ash_blog_newline_hack__  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Absinthe.Schema</span><span class="w">__ash_blog_newline_hack__  </span><span class="n">...</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__  </span><span class="n">query</span><span class="w"> </span><span class="k" data-group-id="7493131802-2">do</span><span class="w">__ash_blog_newline_hack__    </span><span class="na">@desc</span><span class="w"> </span><span class="s">&quot;Get all posts&quot;</span><span class="w">__ash_blog_newline_hack__    </span><span class="n">field</span><span class="w"> </span><span class="ss">:posts</span><span class="p">,</span><span class="w"> </span><span class="n">list_of</span><span class="p" data-group-id="7493131802-3">(</span><span class="ss">:post</span><span class="p" data-group-id="7493131802-3">)</span><span class="w"> </span><span class="k" data-group-id="7493131802-4">do</span><span class="w">__ash_blog_newline_hack__      </span><span class="n">resolve</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">Resolvers.Content</span><span class="o">.</span><span class="n">list_posts</span><span class="o">/</span><span class="mi">3</span><span class="w">__ash_blog_newline_hack__    </span><span class="k" data-group-id="7493131802-4">end</span><span class="w">__ash_blog_newline_hack__  </span><span class="k" data-group-id="7493131802-2">end</span><span class="w">__ash_blog_newline_hack__</span><span class="k" data-group-id="7493131802-1">end</span></code></pre><p>__ash_blog_newline_hack__  Finally, lets take a look at some code from an__ash_blog_newline_hack__<a href="https://hexdocs.pm/ash/Ash.Resource.html"><code class="inline maybe-module text-black dark:text-white" data-module="Ash.Resource">Ash.Resource</code></a>  . I’ll choose a relatively complex example, specifically the defining of an “action”.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="n">create</span><span class="w"> </span><span class="ss">:create</span><span class="w"> </span><span class="k" data-group-id="2707654729-1">do</span><span class="w">__ash_blog_newline_hack__  </span><span class="n">primary?</span><span class="w"> </span><span class="no">true</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="2707654729-2">[</span><span class="ss">:text</span><span class="p" data-group-id="2707654729-2">]</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__  </span><span class="n">argument</span><span class="w"> </span><span class="ss">:public</span><span class="p">,</span><span class="w"> </span><span class="ss">:boolean</span><span class="w"> </span><span class="k" data-group-id="2707654729-3">do</span><span class="w">__ash_blog_newline_hack__    </span><span class="n">allow_nil?</span><span class="w"> </span><span class="no">false</span><span class="w">__ash_blog_newline_hack__    </span><span class="n">default</span><span class="w"> </span><span class="no">true</span><span class="w">__ash_blog_newline_hack__  </span><span class="k" data-group-id="2707654729-3">end</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__  </span><span class="n">change</span><span class="w"> </span><span class="k" data-group-id="2707654729-4">fn</span><span class="w"> </span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">__ash_blog_newline_hack__    </span><span class="k">if</span><span class="w"> </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">get_argument</span><span class="p" data-group-id="2707654729-5">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="ss">:public</span><span class="p" data-group-id="2707654729-5">)</span><span class="w"> </span><span class="k" data-group-id="2707654729-6">do</span><span class="w">__ash_blog_newline_hack__      </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">force_change_attribute</span><span class="p" data-group-id="2707654729-7">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="ss">:visibility</span><span class="p">,</span><span class="w"> </span><span class="ss">:public</span><span class="p" data-group-id="2707654729-7">)</span><span class="w">__ash_blog_newline_hack__    </span><span class="k" data-group-id="2707654729-6">else</span><span class="w">__ash_blog_newline_hack__      </span><span class="n">changeset</span><span class="w">__ash_blog_newline_hack__    </span><span class="k" data-group-id="2707654729-6">end</span><span class="w">__ash_blog_newline_hack__  </span><span class="k" data-group-id="2707654729-4">end</span><span class="w">__ash_blog_newline_hack____ash_blog_newline_hack__  </span><span class="n">change</span><span class="w"> </span><span class="n">relate_actor</span><span class="p" data-group-id="2707654729-8">(</span><span class="ss">:author</span><span class="p" data-group-id="2707654729-8">)</span><span class="w">__ash_blog_newline_hack__</span><span class="k" data-group-id="2707654729-1">end</span></code></pre><p>__ash_blog_newline_hack__  For those not familiar with Ash, lets break it down.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<ul>__ash_blog_newline_hack__  <li>__ash_blog_newline_hack__    <p>__ash_blog_newline_hack__<code class="inline text-black dark:text-white">primary? true</code>      means that if something wants to create one of these, this is the action it should call by default. This is used by certain internal actions and can be used by you or other extensions to determine which action to call in lieu of an explicitly configured action.__ash_blog_newline_hack__    </p>__ash_blog_newline_hack__  </li>__ash_blog_newline_hack__  <li>__ash_blog_newline_hack__    <p>__ash_blog_newline_hack__<code class="inline text-black dark:text-white">accept [:text]</code>      means that you can set the__ash_blog_newline_hack__<code class="inline text-black dark:text-white">text</code>      attribute when calling this action.__ash_blog_newline_hack__    </p>__ash_blog_newline_hack__  </li>__ash_blog_newline_hack__  <li>__ash_blog_newline_hack__    <p>__ash_blog_newline_hack__<code class="inline text-black dark:text-white">argument :public, :boolean, …</code>      adds an additional input to the action that doesn’t map to an attribute, called__ash_blog_newline_hack__<code class="inline text-black dark:text-white">:public</code>      that must have a value, but defaults to__ash_blog_newline_hack__<code class="inline text-black dark:text-white">true</code>      .__ash_blog_newline_hack__    </p>__ash_blog_newline_hack__  </li>__ash_blog_newline_hack__  <li>__ash_blog_newline_hack__    <p>__ash_blog_newline_hack__      The anonymous function you see with__ash_blog_newline_hack__<code class="inline text-black dark:text-white">change fn changeset, _ -></code>      is what we call an “inline change”. A__ash_blog_newline_hack__<code class="inline text-black dark:text-white">change</code>      is a function that takes a changes and returns a changeset. If you’ve worked with Phoenix or with Plug, you’ll recognize this pattern, it works effectively the same as__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Plug">Plug</code>      , working on a__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Conn">Conn</code>      . Except in this case, its a__ash_blog_newline_hack__<code class="inline text-black dark:text-white">change</code>      working on an__ash_blog_newline_hack__<a href="https://hexdocs.pm/ash/Ash.Changeset.html"><code class="inline maybe-module text-black dark:text-white" data-module="Ash.Changeset">Ash.Changeset</code></a>      . We use this argument to map a boolean toggle input to an enumerated attribute.__ash_blog_newline_hack__<code class="inline text-black dark:text-white">change relate_actor(:author)</code>      refers to a “built in change”. This change is provided by Ash out of the box, and this relates the actor (A.K.A current user) to the thing that was just created as the__ash_blog_newline_hack__<code class="inline text-black dark:text-white">:author</code>      .__ash_blog_newline_hack__    </p>__ash_blog_newline_hack__  </li>__ash_blog_newline_hack__</ul>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  These are all macros! However, they again map to an introspectable structure, acting more as configuration than as a traditional macro.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<pre class="code-pre"><code class="not-prose makeup elixir highlight"><span class="gp unselectable">iex(1)&gt; </span><span class="nc">Ash.Resource.Info</span><span class="o">.</span><span class="n">action</span><span class="p" data-group-id="8003445596-1">(</span><span class="nc">Twitter.Tweets.Tweet</span><span class="p">,</span><span class="w"> </span><span class="ss">:create</span><span class="p" data-group-id="8003445596-1">)</span><span class="w">__ash_blog_newline_hack__</span><span class="p" data-group-id="8003445596-2">%</span><span class="nc" data-group-id="8003445596-2">Ash.Resource.Actions.Create</span><span class="p" data-group-id="8003445596-2">{</span><span class="w">__ash_blog_newline_hack__  </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:create</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__  </span><span class="ss">primary?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__  </span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="ss">:create</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__  </span><span class="err">…</span><span class="w">__ash_blog_newline_hack__  </span><span class="ss">arguments</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8003445596-3">[</span><span class="w">__ash_blog_newline_hack__    </span><span class="p" data-group-id="8003445596-4">%</span><span class="nc" data-group-id="8003445596-4">Ash.Resource.Actions.Argument</span><span class="p" data-group-id="8003445596-4">{</span><span class="w">__ash_blog_newline_hack__      </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:public</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__      </span><span class="err">…</span><span class="w">__ash_blog_newline_hack__    </span><span class="p" data-group-id="8003445596-4">}</span><span class="w">__ash_blog_newline_hack__  </span><span class="p" data-group-id="8003445596-3">]</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__  </span><span class="ss">changes</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8003445596-5">[</span><span class="w">__ash_blog_newline_hack__    </span><span class="p" data-group-id="8003445596-6">%</span><span class="nc" data-group-id="8003445596-6">Ash.Resource.Change</span><span class="p" data-group-id="8003445596-6">{</span><span class="n">...</span><span class="p" data-group-id="8003445596-6">}</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__    </span><span class="p" data-group-id="8003445596-7">%</span><span class="nc" data-group-id="8003445596-7">Ash.Resource.Change</span><span class="p" data-group-id="8003445596-7">{</span><span class="w">__ash_blog_newline_hack__      </span><span class="ss">change</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8003445596-8">{</span><span class="nc">Ash.Resource.Change.RelateActor</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__       </span><span class="p" data-group-id="8003445596-9">[</span><span class="ss">allow_nil?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p">,</span><span class="w"> </span><span class="ss">relationship</span><span class="p">:</span><span class="w"> </span><span class="ss">:author</span><span class="p" data-group-id="8003445596-9">]</span><span class="p" data-group-id="8003445596-8">}</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__      </span><span class="err">…</span><span class="w">__ash_blog_newline_hack__    </span><span class="p" data-group-id="8003445596-7">}</span><span class="w">__ash_blog_newline_hack__  </span><span class="p" data-group-id="8003445596-5">]</span><span class="p">,</span><span class="w">__ash_blog_newline_hack__  </span><span class="err">…</span><span class="w">__ash_blog_newline_hack__</span><span class="p" data-group-id="8003445596-2">}</span></code></pre><p>__ash_blog_newline_hack__  This inversion of control is something we’re familiar with in other tools like__ash_blog_newline_hack__<code class="inline maybe-module text-black dark:text-white" data-module="Plug">Plug</code>  or__ash_blog_newline_hack__<code class="inline text-black dark:text-white">Phoenix.Endpoint/Router</code>  . They are great examples of how this pattern can allow for code reuse, and make complex chains of behavior easier to reason about.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<h2 id="its-not-necessarily-about-macros" class="flex flex-row items-center">__ash_blog_newline_hack__  <a href="#its-not-necessarily-about-macros">__ash_blog_newline_hack__    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">__ash_blog_newline_hack__      <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1">__ash_blog_newline_hack__      </path>__ash_blog_newline_hack__    </svg>__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  <span>__ash_blog_newline_hack__    Its not necessarily about macros__ash_blog_newline_hack__  </span>__ash_blog_newline_hack__</h2>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  Above I’ve made a case for macros not necessarily being what gives Ash its relatively steep learning curve. We’ve also create a large suite of tools to mitigate the difficulties that these configuration macros can have. Take a look at__ash_blog_newline_hack__  <a href="spark">__ash_blog_newline_hack__    https://hex.pm/packages/spark__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  for more information on those tools.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  With that said, in that one example above, we had to add five new words to our vocabulary. This is what can make Ash difficult. When you set out to write your own application patterns, you can let your own vocabulary evolve. This provides a natural learning curve. I’d also argue that it gives you tons of opportunities to repeat the mistakes of every developer who went through that same process.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<h2 id="therein-lies-the-rub" class="flex flex-row items-center">__ash_blog_newline_hack__  <a href="#therein-lies-the-rub">__ash_blog_newline_hack__    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">__ash_blog_newline_hack__      <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1">__ash_blog_newline_hack__      </path>__ash_blog_newline_hack__    </svg>__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  <span>__ash_blog_newline_hack__    Therein lies the rub__ash_blog_newline_hack__  </span>__ash_blog_newline_hack__</h2>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  Ash presents a huge suite of integrated tools, a suite that gets bigger and bigger every day and, in order to leverage it, you need to learn a whole new way of doing things. This is a very valid reason not to use Ash. Our biggest proponents will tell you that it’s worth it to put in the effort to learn these tools. As would I. And I don’t mean for the idea of what the framework may become, but for the benefits you can get right now.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  With that said, I think a diversity of mindsets is the most important thing that we can foster as a community, and there is a fine line between telling people “Hey, I think we’ve got some good ideas over here, I think you should check them out”, and saying “Hey, this is the right way to do things, stop doing things your way and do them our way”. So while I’m of course a proponent of Ash, my plan is not to__ash_blog_newline_hack__  <em>__ash_blog_newline_hack__    talk anyone into using it__ash_blog_newline_hack__  </em>__ash_blog_newline_hack__  . I have one simple goal, which is to continue to expand this integrated suite of tools, adding new capabilities that are only possible for things built in this way. Ash is a snowball, rolling down a hill, and it has barely even begun to gather snow. By doing this, we move the threshold by which cost of learning the “Ash way” is offset by the benefits. For many users (more every day) that threshold has already been crossed. For others, it may never be crossed, and thats okay 😊. If the tools we build can help even one person find success on their Elixir journey, then I’m a happy camper.__ash_blog_newline_hack__</p>__ash_blog_newline_hack__<h2 id="parting-words" class="flex flex-row items-center">__ash_blog_newline_hack__  <a href="#parting-words">__ash_blog_newline_hack__    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">__ash_blog_newline_hack__      <path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1">__ash_blog_newline_hack__      </path>__ash_blog_newline_hack__    </svg>__ash_blog_newline_hack__  </a>__ash_blog_newline_hack__  <span>__ash_blog_newline_hack__    Parting Words__ash_blog_newline_hack__  </span>__ash_blog_newline_hack__</h2>__ash_blog_newline_hack__<p>__ash_blog_newline_hack__  The cost of learning something like Ash is not trivial. It depends on you, your problem space, your experience level, and many other factors as to whether or not that juice is worth the squeeze. My goal, and the core team’s goal, is to continue to provide leverage for those already using Ash. To take the patterns we’ve set down and take them even further, increasing the value of our existing users’ investments. Partially because we count among those users, but also because we believe in what we’re building and its ability to help us and others build bigger and better software.__ash_blog_newline_hack__</p>'
inserted_at: "2023-05-11 19:39:18.027487Z"
updated_at: "2023-05-11 20:00:29.800042Z"
---

A common criticism of Ash is that it has too many macros. This is an understandable position to take, but I think its important to distinguish between two main kinds of macros. One of them should be used extremely sparingly, and the other I think its okay to use a bit more liberally. We'll call them "configuration macros" and "metaprogramming macros". Keep in mind these names are a bit made up and the boundary between the two is not always cut and dry. When people talk about "magic" in the context of macros, they are mostly talking about "metaprogramming macros". Lets take a look at some examples.

## Metaprogramming Macros

This snippet is from [NX](https://github.com/elixir-nx/nx/tree/main/nx#readme). This function can run as regular elixir code, or it can be compiled to run using multiple backends meant for numerical processing, including running on the GPU. The code that is actually compiled under the hood looks _dramatically_ different from what you see in front of you. This is not a bad thing! If you had to use or write the actual underlying code, you'd get nothing done. Check out Nx's documentation for more.

```elixir
defn softmax(t) do
  Nx.exp(t) / Nx.sum(Nx.exp(t))
end
```

Here is an example from `Nebulex`, an ETS based caching library. In this example, the metaprogramming is quite hidden from you. The actual logic happens in a [_compiler callback_](https://hexdocs.pm/elixir/1.12/Module.html#module-compile-callbacks). It involves rewriting the functions to intercept calls and decide if the cached version should be used, or if the value should be computed and cached. This kind of macro is quite magical given how indirect it is, but at the same time in applications where cached functions are common, it stops feeling like magic and starts feeling like a language feature. If I was looking at a large code-base that used this once, I'd likely be concerned. The mental overhead of understanding it for one single case likely isn't worth it.

```elixir
defmodule MyApp.Example do
  use Nebulex.Caching

  @decorate cacheable(cache: MyApp.Cache, key: :cache_key)
  def get_by_name(name, age) do
    ...
  end
end
```

This one is from `Ash`. We do similar magic to the `Nx` example from above for this. Specifically, we have an expression that can be run natively to a data layer (i.e `SQL`) or in elixir. And Ash reserves the right to decide where it gets run, depending on the context and requirements.

```elixir
calculate :full_name, :string, expr(first_name <> " " <> last_name)
```

As you can see, all of these examples represent a significant amount of complexity boiled down to very simple macros. This will also be true of the upcoming examples of "configuration macros", but the big difference here is that each macro call represents very complex code being executed on your behalf.

## Configuration Macros

Lets take a look at some examples of macros that I would consider _less_ magical.

This one is likely familiar to most people who have worked with Elixir professionally. Here we have an Ecto.Schema. In this example we actually have three separate macros. The `schema/2` macro sets up some module attributes, and `field/2` adds to those module attributes. `timestamps/0` sets up the schema to track `inserted_at` and `updated_at` timestamps. On its own, however, an `Ecto.Schema` doesn't really _do_ anything. There also isn't a bunch of code hidden behind the scenes that you need to be aware of being executed. This sets up some information on the module that can be read back later. For example: `MyApp.MySchema.__schema__(:fields)` would return `[:field_name, :inserted_at, :updated_at]` in this case. This is a classic example of what I'd call a "configuration macro".

```elixir
defmodule MyApp.MySchema do
  schema "table" do
    field :field_name, :type

    timestamps()
  end
end
```

Here we can see an example from `Absinthe`'s documentation. Absinthe is a tool for building GraphQL apis with Elixir. This one slightly straddles the line between "configuration macros" and "metaprogramming macros", but I think still lands on the side of a "configuration macro". We configure a field in our GraphQL API, and how to resolve it. There are quite a few macros involved in building an API with `Absinthe`. Here we configure what code gets run to resolve a given field, but ultimately the responsibility for what code runs is our own.

```elixir
defmodule BlogWeb.Schema do
  use Absinthe.Schema
  ...

  query do
    @desc "Get all posts"
    field :posts, list_of(:post) do
      resolve &Resolvers.Content.list_posts/3
    end
  end
end
```

Finally, lets take a look at some code from an `Ash.Resource`. I'll choose a relatively complex example, specifically the defining of an "action".

```elixir
create :create do
  primary? true

  accept [:text]

  argument :public, :boolean do
    allow_nil? false
    default true
  end

  change fn changeset, _ ->
    if Ash.Changeset.get_argument(changeset, :public) do
      Ash.Changeset.force_change_attribute(changeset, :visibility, :public)
    else
      changeset
    end
  end

  change relate_actor(:author)
end
```

For those not familiar with Ash, lets break it down.

- `primary? true` means that if something wants to create one of these, this is the action it should call by default. This is used by certain internal actions and can be used by you or other extensions to determine which action to call in lieu of an explicitly configured action.

- `accept [:text]` means that you can set the `text` attribute when calling this action.

- `argument :public, :boolean, …` adds an additional input to the action that doesn’t map to an attribute, called `:public` that must have a value, but defaults to `true`.

- The anonymous function you see with `change fn changeset, _ ->` is what we call an "inline change". A `change` is a function that takes a changes and returns a changeset. If you’ve worked with Phoenix or with Plug, you’ll recognize this pattern, it works effectively the same as `Plug`, working on a `Conn`. Except in this case, its a `change` working on an `Ash.Changeset`. We use this argument to map a boolean toggle input to an enumerated attribute.
  `change relate_actor(:author)` refers to a "built in change". This change is provided by Ash out of the box, and this relates the actor (A.K.A current user) to the thing that was just created as the `:author`.

These are all macros! However, they again map to an introspectable structure, acting more as configuration than as a traditional macro.

```elixir
iex(1)> Ash.Resource.Info.action(Twitter.Tweets.Tweet, :create)
%Ash.Resource.Actions.Create{
  name: :create,
  primary?: true,
  type: :create,
  …
  arguments: [
    %Ash.Resource.Actions.Argument{
      name: :public,
      …
    }
  ],
  changes: [
    %Ash.Resource.Change{...},
    %Ash.Resource.Change{
      change: {Ash.Resource.Change.RelateActor,
       [allow_nil?: false, relationship: :author]},
      …
    }
  ],
  …
}
```

This inversion of control is something we're familiar with in other tools like `Plug` or `Phoenix.Endpoint/Router`. They are great examples of how this pattern can allow for code reuse, and make complex chains of behavior easier to reason about.

## Its not necessarily about macros

Above I've made a case for macros not necessarily being what gives Ash its relatively steep learning curve. We've also create a large suite of tools to mitigate the difficulties that these configuration macros can have. Take a look at [https://hex.pm/packages/spark](spark) for more information on those tools.

With that said, in that one example above, we had to add five new words to our vocabulary. This is what can make Ash difficult. When you set out to write your own application patterns, you can let your own vocabulary evolve. This provides a natural learning curve. I'd also argue that it gives you tons of opportunities to repeat the mistakes of every developer who went through that same process.

## Therein lies the rub

Ash presents a huge suite of integrated tools, a suite that gets bigger and bigger every day and, in order to leverage it, you need to learn a whole new way of doing things. This is a very valid reason not to use Ash. Our biggest proponents will tell you that it’s worth it to put in the effort to learn these tools. As would I. And I don’t mean for the idea of what the framework may become, but for the benefits you can get right now.

With that said, I think a diversity of mindsets is the most important thing that we can foster as a community, and there is a fine line between telling people "Hey, I think we’ve got some good ideas over here, I think you should check them out", and saying "Hey, this is the right way to do things, stop doing things your way and do them our way". So while I’m of course a proponent of Ash, my plan is not to _talk anyone into using it_. I have one simple goal, which is to continue to expand this integrated suite of tools, adding new capabilities that are only possible for things built in this way. Ash is a snowball, rolling down a hill, and it has barely even begun to gather snow. By doing this, we move the threshold by which cost of learning the "Ash way" is offset by the benefits. For many users (more every day) that threshold has already been crossed. For others, it may never be crossed, and thats okay 😊. If the tools we build can help even one person find success on their Elixir journey, then I’m a happy camper.

## Parting Words

The cost of learning something like Ash is not trivial. It depends on you, your problem space, your experience level, and many other factors as to whether or not that juice is worth the squeeze. My goal, and the core team's goal, is to continue to provide leverage for those already using Ash. To take the patterns we've set down and take them even further, increasing the value of our existing users' investments. Partially because we count among those users, but also because we believe in what we're building and its ability to help us and others build bigger and better software.
